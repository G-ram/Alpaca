#include "blas.h"
#include "fixed.h"
#include "mat.h"

void convolve2d(mat *src, uint size, const fixed filter[][size], mat *dest) {
	uint rows = MAT_GET_DIM(src, 0);
	uint cols = MAT_GET_DIM(src, 1);
	uint drows = MAT_GET_DIM(dest, 0);
	uint dcols = MAT_GET_DIM(dest, 1);
	for(uint i = 0; i < drows; i ++) {
		for(uint j = 0; j < dcols; j ++) {
			MAT_SET(dest, F_LIT(0.0), i, j);
			for(int k = 0; k < size; k ++) {
				int irow_idx = i + k;
				for(int l = 0; l < size; l ++) {
					int icol_idx = j + l;
					if(irow_idx >= 0 && irow_idx < rows && icol_idx >= 0 && 
						icol_idx < cols) {
						fixed w = F_ADD(MAT_GET(dest, i, j),
							F_MUL(MAT_GET(src, irow_idx, icol_idx), filter[k][l]));
						MAT_SET(dest, w, i, j);
					}
				}
			}
		}
	}
}

void convolve3d(mat *src, uint size, const fixed filter[][size][size], mat *dest) {
	uint layers = MAT_GET_DIM(src, 0);
	uint drows = MAT_GET_DIM(dest, 0);
	uint dcols = MAT_GET_DIM(dest, 1);
	for(uint i = 0; i < drows; i ++) {
		for(uint j = 0; j < dcols; j ++) {
			MAT_SET(dest, F_LIT(0.0), i, j);
		}
	}
	fixed data[drows * dcols];
	mat it;
	mat *inter = &it;
	inter->data = data;
	MAT_RESHAPE(inter, drows, dcols);
	for(uint i = 0; i < layers; i++) {
		MAT_CONSTRAIN(src, i);
		convolve2d(src, size, filter[i], inter);
		MAT_UNCONSTRAIN(src);
		for(uint j = 0; j < drows; j ++) {
			for(uint k = 0; k < dcols; k ++) {
				fixed w = F_ADD(MAT_GET(dest, j, k), MAT_GET(inter, j, k));
				MAT_SET(dest, w, j, k);
			}
		}
	}
}

void mul_vector(uint rows, uint cols, const fixed mat_data[][cols], mat *vector, 
	mat *dest) {
	for(uint i = 0; i < rows; i ++) {
		MAT_SET(dest, F_LIT(0.0), i);
		for(uint j = 0; j < cols; j ++) {
			fixed w = F_ADD(MAT_GET(dest, i), F_MUL(mat_data[i][j], MAT_GET(vector, j))); 
			MAT_SET(dest, w, i);
		}
	}
}

void sparse_mul_vector(uint rows, const fixed mat_data[], const uint mat_idx[], 
	const uint mat_ptr[], mat *vector, mat *dest) {
	for(uint i = 0; i < rows; i ++) {
		MAT_SET(dest, F_LIT(0.0), i);
		for(uint j = mat_ptr[i]; j < mat_ptr[i + 1]; j ++) {
			fixed w = F_ADD(MAT_GET(dest, i), F_MUL(mat_data[j], MAT_GET(vector, mat_idx[j]))); 
			MAT_SET(dest, w, i);
		}
	}
}

void bias2d(mat *src, const fixed bias, mat *dest) {
	uint rows = MAT_GET_DIM(src, 0); 
	uint cols = MAT_GET_DIM(src, 1);
	for(uint i = 0; i < rows; i ++) {
		for(uint j = 0; j < cols; j ++) {
			MAT_SET(dest, F_ADD(MAT_GET(src, i, j), bias), i, j);
		}
	}
}

void bias1d(mat *src, const fixed bias[], mat *dest) {
	uint rows = MAT_GET_DIM(src, 0); 
	for(uint i = 0; i < rows; i ++) {
		MAT_SET(dest, F_ADD(MAT_GET(src, i), bias[i]), i);
	}
}

void pool(mat *src, uint size, uint stride, mat *dest) {
	uint layers = MAT_GET_DIM(src, 0);
	uint rows = MAT_GET_DIM(src, 1);
	uint cols = MAT_GET_DIM(src, 2);
	for(uint i = 0; i < layers; i ++) {
		for(uint j = 0; j < rows; j += stride) {
			for(uint k = 0; k < cols; k += stride) {
				fixed max = MAT_GET(src, i, j, k);
				for(uint l = 0; l < size; l ++) {
					for(uint m = 0; m < size; m ++) {
						fixed val = MAT_GET(src, i, j + l, k + m);
						if(F_LT(max, val))
							max = val;
					}
				}
				MAT_SET(dest, max, i, j / stride, k / stride);
			}
		}
	}
}

void relu(mat *src, mat *dest) {
	uint rows = MAT_GET_DIM(src, 0);
	fixed max = F_LIT(0.0);
	for(uint i = 0; i < rows; i ++) {
		max = MAT_GET(src, i);
		MAT_SET(dest, max, i);
		if(F_LT(max, F_LIT(0.0)))
			MAT_SET(dest, F_LIT(0.0), i);
	}
}